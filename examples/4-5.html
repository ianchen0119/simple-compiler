<!DOCTYPE html>
<html>
  <head>
    <title>Semantic - section 5</title>

    <style type="text/css">
      #wescriptSrc {
        margin: 10px 0;
      }

      #wescriptSrc .content {
        border: 1px solid orange;
        padding: 10px;
      }

      #error {
        color: red;
        line-height: 1.2;
        margin: 5px 0;
      }
    </style>

    <!-- of course we need jQuery -->
    <script
      src="https://code.jquery.com/jquery-3.4.1.slim.min.js"
      integrity="sha256-pasqAKBDmFT4eHoN2ndd6lN370kFiGUFyTiUHWhU7k8="
      crossorigin="anonymous"
    ></script>

    <!-- the wescript to be compiled will be stored here -->
    <script id="wescript" type="text/wescript">
      var a:int = 3 / 5;
      a= a++ + a-- - ++a + --a;

      var b:bool = ! true && ! false || (1 + 3 == -3);
      b+=3;

      while (1 == 3){
      }

      if (b + 1){
      }
    </script>

    <script type="text/javascript">
      function extend(subClass, baseClass) {
        function inheritance() {}
        inheritance.prototype = baseClass.prototype;

        subClass.prototype = new inheritance();
        subClass.prototype.constructor = subClass;
        subClass.baseConstructor = baseClass;
        subClass.superClass = baseClass.prototype;
      }
    </script>

    <!-- our compiler -->
    <script type="text/javascript">
      function Errors() {}

      Errors.errors = [];

      Errors.push = function(obj) {
        Errors.errors.push(obj);
      };

      Errors.each = function(func) {
        for (var i = 0, l = Errors.errors.length; i < l; i++) {
          func(Errors.errors[i], i);
        }
      };

      Errors.SYNTAX_ERROR = 0;
      Errors.SEMANTIC_ERROR = 1;

      Errors.type = ["Syntax error", "Semantic error"];
    </script>
    <script type="text/javascript">
      //Reader class

      //str is the data to be read
      function Reader(str) {
        this.data = str;
        this.currPos = 0;
        this.dataLength = str.length;
      }

      Reader.prototype.nextChar = function() {
        if (this.currPos >= this.dataLength) {
          return -1; //end of stream
        }
        return this.data[this.currPos++];
      };

      //n is the number of characters to be retracted
      Reader.prototype.retract = function(n) {
        if (n == undefined) {
          n = 1;
        }
        this.currPos -= n;
        if (this.currPos < 0) {
          this.currPos = 0;
        }
      };
    </script>
    <script type="text/javascript">
      //Token class

      //type: Token's type
      //text: the actual text that makes this token, may be null if it is not important
      function Token(type, text) {
        this.type = type;
        this.text = text;
      }

      Token.tokens = {};
      Token.tokens.EOS_TOKEN = 1; //end of stream
      // using + 1 allows adding a new token easily later
      Token.tokens.COLON_TOKEN = Token.tokens.EOS_TOKEN + 1;
      Token.tokens.SEMICOLON_TOKEN = Token.tokens.COLON_TOKEN + 1;
      Token.tokens.LEFTPAREN_TOKEN = Token.tokens.SEMICOLON_TOKEN + 1;
      Token.tokens.RIGHTPAREN_TOKEN = Token.tokens.LEFTPAREN_TOKEN + 1;
      Token.tokens.LEFTBRACE_TOKEN = Token.tokens.RIGHTPAREN_TOKEN + 1;
      Token.tokens.RIGHTBRACE_TOKEN = Token.tokens.LEFTBRACE_TOKEN + 1;
      Token.tokens.MOD_TOKEN = Token.tokens.RIGHTBRACE_TOKEN + 1;

      Token.tokens.VAR_TOKEN = Token.tokens.MOD_TOKEN + 1;
      Token.tokens.TYPE_TOKEN = Token.tokens.VAR_TOKEN + 1;
      Token.tokens.BOOLLITERAL_TOKEN = Token.tokens.TYPE_TOKEN + 1;
      Token.tokens.INTLITERAL_TOKEN = Token.tokens.BOOLLITERAL_TOKEN + 1;
      Token.tokens.IF_TOKEN = Token.tokens.INTLITERAL_TOKEN + 1;
      Token.tokens.ELSE_TOKEN = Token.tokens.IF_TOKEN + 1;
      Token.tokens.WHILE_TOKEN = Token.tokens.ELSE_TOKEN + 1;
      Token.tokens.PRINT_TOKEN = Token.tokens.WHILE_TOKEN + 1;
      Token.tokens.IDENTIFIER_TOKEN = Token.tokens.PRINT_TOKEN + 1;

      Token.tokens.PLUS_TOKEN = Token.tokens.IDENTIFIER_TOKEN + 1;
      Token.tokens.PLUSPLUS_TOKEN = Token.tokens.PLUS_TOKEN + 1;
      Token.tokens.PLUSASSIGN_TOKEN = Token.tokens.PLUSPLUS_TOKEN + 1;
      Token.tokens.MINUS_TOKEN = Token.tokens.PLUSASSIGN_TOKEN + 1;
      Token.tokens.MINUSMINUS_TOKEN = Token.tokens.MINUS_TOKEN + 1;
      Token.tokens.MINUSASSIGN_TOKEN = Token.tokens.MINUSMINUS_TOKEN + 1;
      Token.tokens.MULT_TOKEN = Token.tokens.MINUSASSIGN_TOKEN + 1;
      Token.tokens.DIV_TOKEN = Token.tokens.MULT_TOKEN + 1;
      Token.tokens.ASSIGN_TOKEN = Token.tokens.DIV_TOKEN + 1;
      Token.tokens.EQUAL_TOKEN = Token.tokens.ASSIGN_TOKEN + 1;
      Token.tokens.NOTEQUAL_TOKEN = Token.tokens.EQUAL_TOKEN + 1;
      Token.tokens.GREATER_TOKEN = Token.tokens.NOTEQUAL_TOKEN + 1;
      Token.tokens.GREATEREQUAL_TOKEN = Token.tokens.GREATER_TOKEN + 1;
      Token.tokens.LESS_TOKEN = Token.tokens.GREATEREQUAL_TOKEN + 1;
      Token.tokens.LESSEQUAL_TOKEN = Token.tokens.LESS_TOKEN + 1;
      Token.tokens.AND_TOKEN = Token.tokens.LESSEQUAL_TOKEN + 1;
      Token.tokens.OR_TOKEN = Token.tokens.AND_TOKEN + 1;
      Token.tokens.NOT_TOKEN = Token.tokens.OR_TOKEN + 1;

      Token.tokens.LINECOMMENT_TOKEN = Token.tokens.NOT_TOKEN + 1;
      Token.tokens.BLOCKCOMMENT_TOKEN = Token.tokens.LINECOMMENT_TOKEN + 1;
      Token.tokens.NEWLINE_TOKEN = Token.tokens.BLOCKCOMMENT_TOKEN + 1;

      Token.backwardMap = {}; //for inverse look-up
      for (var x in Token.tokens) {
        Token.backwardMap[Token.tokens[x]] = x;
      }
    </script>
    <script type="text/javascript">
      //Scanner class

      //reader: the reader used to read in characters
      function Scanner(reader) {
        this.reader = reader;
        this.currentToken = new Token(); //storing the current analysed token
        this.currLine = 0; //the line number of the current line being read
        this.state = Scanner.START_STATE;
        this.skipNewLine = true;
      }

      Scanner.START_STATE = 1; //every FSM should have a start state
      Scanner.IDENTIFIER_STATE = Scanner.START_STATE + 1;
      Scanner.SLASH_STATE = Scanner.IDENTIFIER_STATE + 1;

      Scanner.prototype.makeToken = function(type, text) {
        this.currentToken.type = type;
        this.currentToken.text = text;
        return type;
      };

      Scanner.prototype.nextToken = function() {
        var bufferStr = "";
        while (true) {
          switch (this.state) {
            case Scanner.START_STATE:
              var c = this.reader.nextChar();

              if ((c >= "a" && c <= "z") || (c >= "A" && c <= "Z")) {
                this.state = Scanner.IDENTIFIER_STATE;
                //we need to remember what the token's text is
                bufferStr = c;
              } else if (c >= "0" && c <= "9") {
                bufferStr = c;
                var d;
                while (true) {
                  d = this.reader.nextChar();
                  if (d >= "0" && d <= "9") {
                    bufferStr += d;
                  } else {
                    this.reader.retract();
                    return this.makeToken(
                      Token.tokens.INTLITERAL_TOKEN,
                      bufferStr
                    );
                  }
                }
              } else {
                switch (c) {
                  case ":":
                    return this.makeToken(Token.tokens.COLON_TOKEN);
                    break;
                  case ";":
                    return this.makeToken(Token.tokens.SEMICOLON_TOKEN);
                    break;
                  case "(":
                    return this.makeToken(Token.tokens.LEFTPAREN_TOKEN);
                    break;
                  case ")":
                    return this.makeToken(Token.tokens.RIGHTPAREN_TOKEN);
                    break;
                  case "{":
                    return this.makeToken(Token.tokens.LEFTBRACE_TOKEN);
                    break;
                  case "}":
                    return this.makeToken(Token.tokens.RIGHTBRACE_TOKEN);
                    break;
                  case "%":
                    return this.makeToken(Token.tokens.MOD_TOKEN);
                    break;

                  case "!":
                    if (this.reader.nextChar() == "=") {
                      return this.makeToken(Token.tokens.NOTEQUAL_TOKEN);
                    } else {
                      //we have consumed one more char in if-condition
                      this.reader.retract();
                      return this.makeToken(Token.tokens.NOT_TOKEN);
                    }
                    break;
                  case "+":
                    var d = this.reader.nextChar();
                    if (d == "=") {
                      return this.makeToken(Token.tokens.PLUSASSIGN_TOKEN);
                    } else if (d == "+") {
                      return this.makeToken(Token.tokens.PLUSPLUS_TOKEN);
                    } else {
                      this.reader.retract();
                      return this.makeToken(Token.tokens.PLUS_TOKEN);
                    }
                    break;
                  case "-":
                    var d = this.reader.nextChar();
                    if (d == "=") {
                      return this.makeToken(Token.tokens.MINUSASSIGN_TOKEN);
                    } else if (d == "-") {
                      return this.makeToken(Token.tokens.MINUSMINUS_TOKEN);
                    } else {
                      this.reader.retract();
                      return this.makeToken(Token.tokens.MINUS_TOKEN);
                    }
                    break;
                  case "*":
                    return this.makeToken(Token.tokens.MULT_TOKEN);
                    break;
                  case "=":
                    if (this.reader.nextChar() == "=") {
                      return this.makeToken(Token.tokens.EQUAL_TOKEN);
                    } else {
                      this.reader.retract();
                      return this.makeToken(Token.tokens.ASSIGN_TOKEN);
                    }
                    break;
                  case ">":
                    if (this.reader.nextChar() == "=") {
                      return this.makeToken(Token.tokens.GREATEREQUAL_TOKEN);
                    } else {
                      this.reader.retract();
                      return this.makeToken(Token.tokens.GREATER_TOKEN);
                    }
                    break;
                  case "<":
                    if (this.reader.nextChar() == "=") {
                      return this.makeToken(Token.tokens.LESSEQUAL_TOKEN);
                    } else {
                      this.reader.retract();
                      return this.makeToken(Token.tokens.LESS_TOKEN);
                    }
                    break;

                  case "/":
                    this.state = Scanner.SLASH_STATE;
                    break;

                  case "&":
                    if (this.reader.nextChar() == "&") {
                      return this.makeToken(Token.tokens.AND_TOKEN);
                    } else {
                      this.reader.retract();
                      Errors.push({
                        type: Errors.SYNTAX_ERROR,
                        msg: "You have only one &",
                        line: this.currLine
                      });
                    }
                    break;
                  case "|":
                    if (this.reader.nextChar() == "|") {
                      return this.makeToken(Token.tokens.OR_TOKEN);
                    } else {
                      this.reader.retract();
                      Errors.push({
                        type: Errors.SYNTAX_ERROR,
                        msg: "You have only one |",
                        line: this.currLine
                      });
                    }
                    break;

                  case -1:
                    return this.makeToken(Token.tokens.EOS_TOKEN);
                    break;
                  case "\r":
                  case "\n":
                    this.currLine++;
                    if (!this.skipNewLine) {
                      return this.makeToken(Token.tokens.NEWLINE_TOKEN);
                    }
                  default:
                  //ignore them
                }
              }
              break;
            case Scanner.IDENTIFIER_STATE:
              var c = this.reader.nextChar();

              if ((c >= "a" && c <= "z") || (c >= "A" && c <= "Z")) {
                bufferStr += c;
              } else {
                //stop reading it since it is not a letter anymore
                //retract the last character we read because it does not belong to this identfier
                this.reader.retract();

                //change back the state to read the next token
                this.state = Scanner.START_STATE;

                switch (bufferStr) {
                  case "var":
                    return this.makeToken(Token.tokens.VAR_TOKEN);
                  case "int":
                  case "bool":
                    //need to pass bufferStr as well to distinguish which type it is
                    return this.makeToken(Token.tokens.TYPE_TOKEN, bufferStr);
                  case "true":
                  case "false":
                  case "TRUE":
                  case "FALSE":
                    return this.makeToken(
                      Token.tokens.BOOLLITERAL_TOKEN,
                      bufferStr
                    );
                  case "if":
                    return this.makeToken(Token.tokens.IF_TOKEN);
                  case "else":
                    return this.makeToken(Token.tokens.ELSE_TOKEN);
                  case "while":
                    return this.makeToken(Token.tokens.WHILE_TOKEN);
                  case "print":
                    return this.makeToken(Token.tokens.PRINT_TOKEN);
                  default:
                    return this.makeToken(
                      Token.tokens.IDENTIFIER_TOKEN,
                      bufferStr
                    );
                }
              }
              break;
            case Scanner.SLASH_STATE:
              var d = this.reader.nextChar();
              if (d == "/") {
                //line comment
                bufferStr = "";
                //reading 1 more char here can prevent the case that a // is followed by a line break char immediately
                d = this.reader.nextChar();
                if (d != "\r" && d != "\n") {
                  while (d != "\r" && d != "\n") {
                    bufferStr += d;
                    d = this.reader.nextChar();
                  }

                  //to retract the line break char
                  this.reader.retract();
                }

                this.state = Scanner.START_STATE;

                return this.makeToken(
                  Token.tokens.LINECOMMENT_TOKEN,
                  bufferStr
                );
              } else if (d == "*") {
                //block comment
                bufferStr = "";
                var end = false;
                while (!end) {
                  d = this.reader.nextChar();
                  if (d != -1) {
                    if (d == "\r" || d == "\n") {
                      this.currLine++;
                    }
                    if (d == "*") {
                      var e = this.reader.nextChar();
                      if (e == "/") {
                        //meet */
                        end = true;
                      } else {
                        bufferStr += "*" + e;
                      }
                    } else {
                      bufferStr += d;
                    }
                  } else {
                    end = true;
                  }
                }

                this.state = Scanner.START_STATE;

                return this.makeToken(
                  Token.tokens.BLOCKCOMMENT_TOKEN,
                  bufferStr
                );
              } else {
                this.state = Scanner.START_STATE;
                this.reader.retract();
                return this.makeToken(Token.tokens.DIV_TOKEN);
              }
              break;
          }
        }
      };
    </script>
    <script type="text/javascript">
      //Nodes

      function Node() {
        this.line = 0;
      }
      Node.prototype.setLine = function(line) {
        this.line = line;
        return this;
      };

      function ExpressionBlockNode() {
        this.expressions = [];
      }

      extend(ExpressionBlockNode, Node);

      ExpressionBlockNode.prototype.push = function(expression) {
        this.expressions.push(expression);
      };

      ExpressionBlockNode.prototype.iterate = function(func) {
        for (var i = 0, l = this.expressions.length; i < l; i++) {
          var expression = this.expressions[i];
          func(expression, i);
        }
      };

      function PrintNode(expressionNode) {
        this.expressionNode = expressionNode;
      }

      extend(PrintNode, Node);

      function IntNode(data) {
        this.data = data;
      }

      extend(IntNode, Node);

      function BoolNode(data) {
        this.data = data;
      }

      extend(BoolNode, Node);

      function VariableNode(varName, type, initExpressionNode) {
        this.varName = varName;
        this.type = type;
        this.initExpressionNode = initExpressionNode;
      }

      extend(VariableNode, Node);

      function IfNode(conditionExpression, expressions, elseExpressions) {
        this.conditionExpression = conditionExpression;
        this.expressions = expressions;
        this.elseExpressions = elseExpressions;
      }

      extend(IfNode, Node);

      function WhileNode(conditionExpression, expressions) {
        this.conditionExpression = conditionExpression;
        this.expressions = expressions;
      }

      extend(WhileNode, Node);

      function IdentifierNode(identifier) {
        this.identifier = identifier;
      }

      extend(IdentifierNode, Node);

      function ParenNode(node) {
        this.node = node;
      }

      extend(ParenNode, Node);

      function NegateNode(node) {
        this.node = node;
      }

      extend(NegateNode, Node);

      function NotNode(node) {
        this.node = node;
      }

      extend(NotNode, Node);

      function CompoundNode() {
        this.nodes = [];
      }

      extend(CompoundNode, Node);

      CompoundNode.prototype.push = function(node) {
        this.nodes.push(node);
      };

      function OperatorNode() {}

      extend(OperatorNode, Node);

      function OperatorPlusNode() {}

      extend(OperatorPlusNode, OperatorNode);

      function OperatorMinusNode() {}

      extend(OperatorMinusNode, OperatorNode);

      function OperatorMultNode() {}

      extend(OperatorMultNode, OperatorNode);

      function OperatorDivNode() {}

      extend(OperatorDivNode, OperatorNode);

      function OperatorModNode() {}

      extend(OperatorModNode, OperatorNode);

      function OperatorAndNode() {}

      extend(OperatorAndNode, OperatorNode);

      function OperatorOrNode() {}

      extend(OperatorOrNode, OperatorNode);

      function OperatorEqualNode() {}

      extend(OperatorEqualNode, OperatorNode);

      function OperatorNotEqualNode() {}

      extend(OperatorNotEqualNode, OperatorNode);

      function OperatorAssignNode() {}

      extend(OperatorAssignNode, OperatorNode);

      function OperatorPlusAssignNode() {}

      extend(OperatorPlusAssignNode, OperatorNode);

      function OperatorMinusAssignNode() {}

      extend(OperatorMinusAssignNode, OperatorNode);

      function PostIncrementNode(node) {
        this.node = node;
      }

      extend(PostIncrementNode, Node);

      function PreIncrementNode(node) {
        this.node = node;
      }

      extend(PreIncrementNode, Node);

      function PostDecrementNode(node) {
        this.node = node;
      }

      extend(PostDecrementNode, Node);

      function PreDecrementNode(node) {
        this.node = node;
      }

      extend(PreDecrementNode, Node);
    </script>
    <script type="text/javascript">
      //Parser class

      function Parser(scanner) {
        this.scanner = scanner;
        this.currentToken = new Token();
        this.lookaheadToken = new Token();
        this.lookaheadToken.consumed = true;
      }

      Parser.prototype.nextToken = function() {
        if (this.lookaheadToken.consumed) {
          var token = this.scanner.nextToken();

          //skip comments
          while (
            token == Token.tokens.LINECOMMENT_TOKEN ||
            token == Token.tokens.BLOCKCOMMENT_TOKEN
          ) {
            token = this.scanner.nextToken();
          }

          this.currentToken.type = token;
          this.currentToken.text = this.scanner.currentToken.text;

          return token;
        } else {
          this.currentToken.type = this.lookaheadToken.type;
          this.currentToken.text = this.lookaheadToken.text;
          this.lookaheadToken.consumed = true;
          return this.currentToken.type;
        }
      };

      Parser.prototype.lookahead = function() {
        if (this.lookaheadToken.consumed) {
          var token = this.scanner.nextToken();

          //skip comments
          while (
            token == Token.tokens.LINECOMMENT_TOKEN ||
            token == Token.tokens.BLOCKCOMMENT_TOKEN
          ) {
            token = this.scanner.nextToken();
          }

          this.lookaheadToken.type = token;
          this.lookaheadToken.text = this.scanner.currentToken.text;
          this.lookaheadToken.consumed = false;

          return token;
        } else {
          return this.lookaheadToken.type;
        }
      };

      //a naive implementation for skipping error
      Parser.prototype.skipError = function() {
        this.scanner.skipNewLine = false;

        while (
          this.lookahead() != Token.tokens.NEWLINE_TOKEN &&
          this.lookahead() != Token.tokens.EOS_TOKEN
        ) {
          this.nextToken();
        }

        this.scanner.skipNewLine = true;
      };

      //the entry point of our parser
      Parser.prototype.parse = function() {
        var rootBlock = new ExpressionBlockNode();

        this.parseExpressions(rootBlock);

        return rootBlock;
      };

      //to parse a list of expressions
      Parser.prototype.parseExpressions = function(expressionBlockNode) {
        while (
          this.lookahead() != Token.tokens.RIGHTBRACE_TOKEN &&
          this.lookahead() != Token.tokens.EOS_TOKEN
        ) {
          var expressionNode = this.parseExpression();

          if (expressionNode) {
            expressionBlockNode.push(expressionNode);
          }
        }
      };

      Parser.prototype.matchSemicolon = function() {
        //consume the semicolon
        if (this.lookahead() == Token.tokens.SEMICOLON_TOKEN) {
          this.nextToken();
        } else {
          //syntax error
          Errors.push({
            type: Errors.SYNTAX_ERROR,
            msg: "Expecting a semicolon at the end of expression",
            line: this.scanner.currLine
          });
        }
      };

      //to parse an expression
      Parser.prototype.parseExpression = function() {
        switch (this.lookahead()) {
          case Token.tokens.PRINT_TOKEN:
            var printToken = this.nextToken();
            var expressionNode = this.parseExpression();
            if (expressionNode == undefined) {
              Errors.push({
                type: Errors.SYNTAX_ERROR,
                msg: 'Missing an expression after "print"',
                line: this.scanner.currLine
              });
            }

            this.matchSemicolon();
            return new PrintNode(expressionNode).setLine(this.scanner.currLine);
            break;

          case Token.tokens.VAR_TOKEN:
            return this.parseVarExpression();
            break;

          case Token.tokens.IF_TOKEN:
            return this.parseIfExpression();
            break;

          case Token.tokens.WHILE_TOKEN:
            return this.parseWhileExpression();
            break;

          /*
          case Token.tokens.INTLITERAL_TOKEN:
              var intToken = this.nextToken();
              return new IntNode(this.currentToken.text);
          break;

          //similar to INTLITERAL_TOKEN
          case Token.tokens.BOOLLITERAL_TOKEN:
              var boolToken = this.nextToken();
              return new BoolNode(this.currentToken.text);
          break;
          */

          default:
            //unexpected, consume it
            return this.parseCompoundExpression(0);
        }
      };

      Parser.prototype.parseOperand = function() {
        var token = this.nextToken();
        var operandNode;
        switch (token) {
          case Token.tokens.INTLITERAL_TOKEN:
            operandNode = new IntNode(this.currentToken.text).setLine(
              this.scanner.currLine
            );
            break;
          case Token.tokens.BOOLLITERAL_TOKEN:
            operandNode = new BoolNode(this.currentToken.text).setLine(
              this.scanner.currLine
            );
            break;
          case Token.tokens.IDENTIFIER_TOKEN:
            operandNode = new IdentifierNode(this.currentToken.text).setLine(
              this.scanner.currLine
            );
            if (this.lookahead() == Token.tokens.MINUSMINUS_TOKEN) {
              //post decrement
              this.nextToken();
              operandNode = new PostDecrementNode(operandNode).setLine(
                this.scanner.currLine
              );
            } else if (this.lookahead() == Token.tokens.PLUSPLUS_TOKEN) {
              //post increment
              this.nextToken();
              operandNode = new PostIncrementNode(operandNode).setLine(
                this.scanner.currLine
              );
            }
            break;
          case Token.tokens.LEFTPAREN_TOKEN:
            operandNode = new ParenNode(
              this.parseCompoundExpression(0)
            ).setLine(this.scanner.currLine);

            //consume the right paren )
            if (this.lookahead() == Token.tokens.RIGHTPAREN_TOKEN) {
              this.nextToken();
            } else {
              Errors.push({
                type: Errors.SYNTAX_ERROR,
                msg: 'Missing right paren ")"',
                line: this.scanner.currLine
              });
            }
            break;
          case Token.tokens.MINUSMINUS_TOKEN:
            if (this.lookahead() == Token.tokens.IDENTIFIER_TOKEN) {
              this.nextToken();
              operandNode = new PreDecrementNode(
                new IdentifierNode(this.currentToken.text)
              ).setLine(this.scanner.currLine);
            } else {
              Errors.push({
                type: Errors.SYNTAX_ERROR,
                msg: "Expecting an identifier for pre-decrement expression",
                line: this.scanner.currLine
              });
              return null;
            }
            break;
          case Token.tokens.PLUSPLUS_TOKEN:
            if (this.lookahead() == Token.tokens.IDENTIFIER_TOKEN) {
              this.nextToken();
              operandNode = new PreIncrementNode(
                new IdentifierNode(this.currentToken.text)
              ).setLine(this.scanner.currLine);
            } else {
              Errors.push({
                type: Errors.SYNTAX_ERROR,
                msg: "Expecting an identifier for pre-increment expression",
                line: this.scanner.currLine
              });
              return null;
            }
            break;
          case Token.tokens.MINUS_TOKEN:
            operandNode = new NegateNode(this.parseOperand()).setLine(
              this.scanner.currLine
            );
            break;
          case Token.tokens.NOT_TOKEN:
            operandNode = new NotNode(this.parseOperand()).setLine(
              this.scanner.currLine
            );
            break;

          case Token.tokens.SEMICOLON_TOKEN:
            return null;
            break;

          default:
            //not valid
            Errors.push({
              type: Errors.SYNTAX_ERROR,
              msg: "Unexpected token",
              line: this.scanner.currLine
            });
            return null;
        }
        return operandNode;
      };

      Parser.prototype.getBindingPower = function(token) {
        switch (token) {
          case Token.tokens.PLUS_TOKEN:
          case Token.tokens.MINUS_TOKEN:
            return 120;
          case Token.tokens.MULT_TOKEN:
          case Token.tokens.DIV_TOKEN:
          case Token.tokens.MOD_TOKEN:
            return 130;
          case Token.tokens.EQUAL_TOKEN:
          case Token.tokens.NOTEQUAL_TOKEN:
            return 90;
          case Token.tokens.AND_TOKEN:
            return 50;
          case Token.tokens.OR_TOKEN:
            return 40;
          case Token.tokens.ASSIGN_TOKEN:
          case Token.tokens.MINUSASSIGN_TOKEN:
          case Token.tokens.PLUSASSIGN_TOKEN:
            return 20;
        }

        return -1;
      };

      Parser.prototype.createOperatorNode = function(operatorToken) {
        switch (operatorToken) {
          case Token.tokens.PLUS_TOKEN:
            return new OperatorPlusNode().setLine(this.scanner.currLine);
            break;
          case Token.tokens.MINUS_TOKEN:
            return new OperatorMinusNode().setLine(this.scanner.currLine);
            break;
          case Token.tokens.MULT_TOKEN:
            return new OperatorMultNode().setLine(this.scanner.currLine);
            break;
          case Token.tokens.DIV_TOKEN:
            return new OperatorDivNode().setLine(this.scanner.currLine);
            break;
          case Token.tokens.MOD_TOKEN:
            return new OperatorModNode().setLine(this.scanner.currLine);
            break;
          case Token.tokens.AND_TOKEN:
            return new OperatorAndNode().setLine(this.scanner.currLine);
            break;
          case Token.tokens.OR_TOKEN:
            return new OperatorOrNode().setLine(this.scanner.currLine);
            break;
          case Token.tokens.EQUAL_TOKEN:
            return new OperatorEqualNode().setLine(this.scanner.currLine);
            break;
          case Token.tokens.NOTEQUAL_TOKEN:
            return new OperatorNotEqualNode().setLine(this.scanner.currLine);
            break;
          case Token.tokens.ASSIGN_TOKEN:
            return new OperatorAssignNode().setLine(this.scanner.currLine);
            break;
          case Token.tokens.PLUSASSIGN_TOKEN:
            return new OperatorPlusAssignNode().setLine(this.scanner.currLine);
            break;
          case Token.tokens.MINUSASSIGN_TOKEN:
            return new OperatorMinusAssignNode().setLine(this.scanner.currLine);
            break;
        }
      };

      Parser.prototype.parseCompoundExpression = function(rightBindingPower) {
        var operandNode = this.parseOperand();
        if (operandNode == null) {
          return operandNode;
        }

        var compoundExpressionNode = new CompoundNode().setLine(
          this.scanner.currLine
        );
        compoundExpressionNode.push(operandNode);

        var operator = this.lookahead();
        var leftBindingPower = this.getBindingPower(operator);
        if (leftBindingPower == -1) {
          //not an operator
          return compoundExpressionNode;
        }

        while (rightBindingPower < leftBindingPower) {
          operator = this.nextToken();
          compoundExpressionNode.push(this.createOperatorNode(operator));
          var node = this.parseCompoundExpression(leftBindingPower);
          compoundExpressionNode.push(node);

          var oper = this.lookahead();
          leftBindingPower = this.getBindingPower(oper);
          if (leftBindingPower == -1) {
            //not an operator
            return compoundExpressionNode;
          }
        }

        return compoundExpressionNode;
      };

      Parser.prototype.parseWhileExpression = function() {
        //consume "while"
        this.nextToken();

        var condition = this.parseParenExpression();

        var expressions = this.parseExpressionBlock();

        return new WhileNode(condition, expressions).setLine(
          this.scanner.currLine
        );
      };

      Parser.prototype.parseIfExpression = function() {
        //consume "if"
        this.nextToken();

        var condition = this.parseParenExpression();

        var expressions = this.parseExpressionBlock();

        var elseExpressions;
        if (this.lookahead() == Token.tokens.ELSE_TOKEN) {
          //consume "else"
          this.nextToken();

          elseExpressions = this.parseExpressionBlock();
        }

        return new IfNode(condition, expressions, elseExpressions).setLine(
          this.scanner.currLine
        );
      };

      Parser.prototype.parseExpressionBlock = function() {
        if (this.lookahead() != Token.tokens.LEFTBRACE_TOKEN) {
          Errors.push({
            type: Errors.SYNTAX_ERROR,
            msg: 'Expecting "{"',
            line: this.scanner.currLine
          });
        } else {
          this.nextToken();
        }

        var block = new ExpressionBlockNode().setLine(this.scanner.currLine);
        var expressions = this.parseExpressions(block);

        if (this.lookahead() != Token.tokens.RIGHTBRACE_TOKEN) {
          Errors.push({
            type: Errors.SYNTAX_ERROR,
            msg: 'Expecting "}"',
            line: this.scanner.currLine
          });
        } else {
          this.nextToken();
        }

        return block;
      };

      Parser.prototype.parseParenExpression = function() {
        if (this.lookahead() != Token.tokens.LEFTPAREN_TOKEN) {
          Errors.push({
            type: Errors.SYNTAX_ERROR,
            msg: 'Expecting "("',
            line: this.scanner.currLine
          });
        } else {
          this.nextToken();
        }

        var expression = this.parseExpression();

        if (this.lookahead() != Token.tokens.RIGHTPAREN_TOKEN) {
          Errors.push({
            type: Errors.SYNTAX_ERROR,
            msg: 'Expecting ")"',
            line: this.scanner.currLine
          });
        } else {
          this.nextToken();
        }

        return expression;
      };

      Parser.prototype.parseVarExpression = function() {
        //consume "var"
        this.nextToken();

        //expecting an identifier
        if (this.lookahead() == Token.tokens.IDENTIFIER_TOKEN) {
          this.nextToken();
          var varName = this.currentToken.text;

          //consume a colon
          if (this.nextToken() != Token.tokens.COLON_TOKEN) {
            this.skipError();
            return;
          }

          //type token
          if (this.lookahead() != Token.tokens.TYPE_TOKEN) {
            this.skipError();
            return;
          }

          this.nextToken();
          var typeName = this.currentToken.text;

          var initNode;
          //check if it has initialization expression
          if (this.lookahead() == Token.tokens.ASSIGN_TOKEN) {
            initNode = this.parseSimpleAssignmentExpression();
          }

          this.matchSemicolon();

          return new VariableNode(varName, typeName, initNode).setLine(
            this.scanner.currLine
          );
        }

        this.skipError();
      };

      Parser.prototype.parseSimpleAssignmentExpression = function() {
        //consume the "=" sign
        this.nextToken();

        var expressionNode = this.parseExpression();
        return expressionNode;
      };
    </script>
    <script type="text/javascript">
      //Analyser class

      function Analyser() {
        this.vars = {};
      }

      Analyser.TYPE_BOOL = 1;
      Analyser.TYPE_INT = 2;

      Analyser.prototype.evaluateExpressionBlockNode = function(node) {
        if (node == null) {
          return;
        }
        for (var i = 0, l = node.expressions.length; i < l; i++) {
          var expressionNode = node.expressions[i];
          this.evaluateExpressionNode(expressionNode);
        }
      };

      Analyser.prototype.evaluateExpressionNode = function(node) {
        if (node instanceof VariableNode) {
          this.evaluateVariableNode(node);
        } else if (node instanceof PrintNode) {
          this.evaluatePrintNode(node);
        } else if (node instanceof CompoundNode) {
          this.evaluateCompoundNode(node);
        } else if (node instanceof IdentifierNode) {
          this.evaluateIdentifierNode(node);
        } else if (node instanceof IntNode) {
          this.evaluateIntNode(node);
        } else if (node instanceof BoolNode) {
          this.evaluateBoolNode(node);
        } else if (node instanceof PostIncrementNode) {
          this.evaluatePostIncrementNode(node);
        } else if (node instanceof PreIncrementNode) {
          this.evaluatePreIncrementNode(node);
        } else if (node instanceof PostDecrementNode) {
          this.evaluatePostDecrementNode(node);
        } else if (node instanceof PreDecrementNode) {
          this.evaluatePreDecrementNode(node);
        } else if (node instanceof NegateNode) {
          this.evaluateNegateNode(node);
        } else if (node instanceof NotNode) {
          this.evaluateNotNode(node);
        } else if (node instanceof ParenNode) {
          this.evaluateParenNode(node);
        } else if (node instanceof IfNode) {
          this.evaluateIfNode(node);
        } else if (node instanceof WhileNode) {
          this.evaluateWhileNode(node);
        }
      };

      Analyser.prototype.evaluateIfNode = function(node) {
        this.evaluateExpressionNode(node.conditionExpression);
        if (node.conditionExpression.valueType != Analyser.TYPE_BOOL) {
          Errors.push({
            type: Errors.SEMANTIC_ERROR,
            msg: "The condition must be of Boolean type",
            line: node.conditionExpression.line
          });
        }

        this.evaluateExpressionBlockNode(node.expressions);
        this.evaluateExpressionBlockNode(node.elseExpressions);
      };

      Analyser.prototype.evaluateWhileNode = function(node) {
        this.evaluateExpressionNode(node.conditionExpression);
        if (node.conditionExpression.valueType != Analyser.TYPE_BOOL) {
          Errors.push({
            type: Errors.SEMANTIC_ERROR,
            msg: "The condition must be of Boolean type",
            line: node.conditionExpression.line
          });
        }

        this.evaluateExpressionBlockNode(node.expressions);
      };

      Analyser.prototype.evaluateNegateNode = function(node) {
        this.evaluateExpressionNode(node.node);
        node.valueType = node.node.valueType;
      };

      Analyser.prototype.evaluateNotNode = function(node) {
        this.evaluateExpressionNode(node.node);
        node.valueType = node.node.valueType;
      };

      Analyser.prototype.evaluateParenNode = function(node) {
        this.evaluateExpressionNode(node.node);
        node.valueType = node.node.valueType;
      };

      Analyser.prototype.evaluatePostIncrementNode = function(node) {
        this.evaluateExpressionNode(node.node);
        node.valueType = node.node.valueType;
      };

      Analyser.prototype.evaluatePreIncrementNode = function(node) {
        this.evaluateExpressionNode(node.node);
        node.valueType = node.node.valueType;
      };

      Analyser.prototype.evaluatePostDecrementNode = function(node) {
        this.evaluateExpressionNode(node.node);
        node.valueType = node.node.valueType;
      };

      Analyser.prototype.evaluatePreDecrementNode = function(node) {
        this.evaluateExpressionNode(node.node);
        node.valueType = node.node.valueType;
      };

      Analyser.prototype.evaluateBoolNode = function(node) {
        node.valueType = Analyser.TYPE_BOOL;
      };

      Analyser.prototype.evaluateIntNode = function(node) {
        node.valueType = Analyser.TYPE_INT;
      };

      Analyser.prototype.evaluateIdentifierNode = function(node) {
        if (!this.vars[node.identifier]) {
          Errors.push({
            type: Errors.SEMANTIC_ERROR,
            msg:
              'Variable "' +
              node.identifier +
              '" must been declared before using',
            line: node.line
          });
        } else {
          node.valueType = this.vars[node.identifier].valueType;
        }
      };

      Analyser.prototype.evaluateCompoundNode = function(node) {
        var type = null;
        var operator = null;
        for (var i = 0, l = node.nodes.length; i < l; i++) {
          var subNode = node.nodes[i];
          this.evaluateExpressionNode(subNode);
          if (type == null) {
            type = subNode.valueType;
          } else {
            if (subNode instanceof OperatorNode) {
              operator = subNode;
            } else {
              if (
                operator instanceof OperatorPlusNode ||
                operator instanceof OperatorMinusNode ||
                operator instanceof OperatorMultNode ||
                operator instanceof OperatorDivNode ||
                operator instanceof OperatorModNode
              ) {
                if (
                  type != Analyser.TYPE_INT ||
                  subNode.valueType != Analyser.TYPE_INT
                ) {
                  Errors.push({
                    type: Errors.SEMANTIC_ERROR,
                    msg:
                      "Require Integers on both sides of arithmetic operator",
                    line: operator.line
                  });
                }
                type = Analyser.TYPE_INT;
                operator = null;
              } else if (
                operator instanceof OperatorAndNode ||
                operator instanceof OperatorOrNode
              ) {
                if (
                  type != Analyser.TYPE_BOOL ||
                  subNode.valueType != Analyser.TYPE_BOOL
                ) {
                  Errors.push({
                    type: Errors.SEMANTIC_ERROR,
                    msg: "Require Booleans on both sides of logical operator",
                    line: operator.line
                  });
                }
                type = Analyser.TYPE_BOOL;
                operator = null;
              } else if (
                operator instanceof OperatorEqualNode ||
                operator instanceof OperatorNotEqualNode
              ) {
                if (
                  (type == Analyser.TYPE_BOOL &&
                    subNode.valueType != Analyser.TYPE_BOOL) ||
                  (type == Analyser.TYPE_INT &&
                    subNode.valueType != Analyser.TYPE_INT)
                ) {
                  Errors.push({
                    type: Errors.SEMANTIC_ERROR,
                    msg:
                      "Require the type on both sides of comparison operator to be the same",
                    line: operator.line
                  });
                }
                type = Analyser.TYPE_BOOL;
                operator = null;
              } else if (operator instanceof OperatorAssignNode) {
                if (
                  (type == Analyser.TYPE_BOOL &&
                    subNode.valueType != Analyser.TYPE_BOOL) ||
                  (type == Analyser.TYPE_INT &&
                    subNode.valueType != Analyser.TYPE_INT)
                ) {
                  Errors.push({
                    type: Errors.SEMANTIC_ERROR,
                    msg:
                      "Require the type on both sides of assignment operator to be the same",
                    line: operator.line
                  });
                }
              } else if (
                operator instanceof OperatorPlusAssignNode ||
                operator instanceof OperatorMinusAssignNode
              ) {
                if (
                  type != Analyser.TYPE_INT ||
                  subNode.valueType != Analyser.TYPE_INT
                ) {
                  Errors.push({
                    type: Errors.SEMANTIC_ERROR,
                    msg:
                      "Require the type on both sides of plus/minus assignment operator to be Integer",
                    line: operator.line
                  });
                }
              }
            }
          }
        }

        node.valueType = type;
      };

      Analyser.prototype.evaluatePrintNode = function(node) {
        this.evaluateExpressionNode(node.expressionNode);
      };

      Analyser.prototype.evaluateVariableNode = function(node) {
        if (this.vars[node.varName]) {
          //this variable has been declared before
          //since we can find it in our variable table
          Errors.push({
            type: Errors.SEMANTIC_ERROR,
            msg:
              'The variable "' + node.varName + '" has been declared already',
            line: node.line
          });
        } else {
          this.vars[node.varName] = node;
          //if we do not use "else", this variable declaration will replace the previous one
          //This may result in wrong data type checking later on
        }

        if (node.initExpressionNode) {
          this.evaluateExpressionNode(node.initExpressionNode);
          if (
            node.type == "bool" &&
            node.initExpressionNode.valueType != Analyser.TYPE_BOOL
          ) {
            Errors.push({
              type: Errors.SEMANTIC_ERROR,
              msg:
                'The variable "' +
                node.varName +
                '" is Boolean type but the assignment value is not Boolean',
              line: node.line
            });
          } else if (
            node.type == "int" &&
            node.initExpressionNode.valueType != Analyser.TYPE_INT
          ) {
            Errors.push({
              type: Errors.SEMANTIC_ERROR,
              msg:
                'The variable "' +
                node.varName +
                '" is Integer type but the assignment value is not Integer',
              line: node.line
            });
          }
        } else {
          if (node.type == "bool") {
            node.initExpressionNode = new BoolNode("false");
          } else if (node.type == "int") {
            node.initExpressionNode = new IntNode("0");
          }
        }

        node.valueType =
          node.type == "bool" ? Analyser.TYPE_BOOL : Analyser.TYPE_INT;
      };
    </script>

    <!-- our tester -->
    <script type="text/javascript">
      function log(str) {
        $("#log").append(str + "<br />");
      }

      function errorLog(str) {
        $("#error").append(str + "<br />");
      }

      $(function() {
        $("#wescriptSrc .content").text($("#wescript").text());
      });

      $(function() {
        //we stored our wescript in <script id="wescript">
        var dataToBeCompiled = $("#wescript").text();
        var reader = new Reader(dataToBeCompiled);
        var scanner = new Scanner(reader);
        var parser = new Parser(scanner);
        var expressionBlockNode = parser.parse();

        var analyser = new Analyser();
        analyser.evaluateExpressionBlockNode(expressionBlockNode);

        console.log(expressionBlockNode);

        Errors.each(function(error, i) {
          errorLog(
            "Line " +
              error.line +
              ": (" +
              Errors.type[error.type] +
              ") " +
              error.msg
          );
        });
      });
    </script>
  </head>

  <body>
    <div id="wescriptSrc">
      <pre class="content"></pre>
    </div>

    <div id="error"></div>

    <div id="log"></div>
  </body>
</html>
